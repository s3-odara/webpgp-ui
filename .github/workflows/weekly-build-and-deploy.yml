name: Weekly build and deploy

on:
  schedule:
    - cron: "0 18 * * 0"
  workflow_dispatch:
  push:
    branches:
      - master

concurrency:
  group: site-deploy
  cancel-in-progress: true

permissions:
  contents: read

env:
  OPENPGPJS_SIGNER_FPRS: |
    twiss:72E33AE81300E553BC4EEDEFCB064A128FA90686
    larabr:DDEBA5D26F64DC406368799F2A4BEC40729185DD

  BROTLI_REGEX: '.*\.(htm|html|txt|text|asc|js|mjs|css|json|xml|svg|map|webmanifest)$'

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 24

      - name: Install brotli
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y brotli

      - name: Fetch latest openpgpjs release tag
        id: release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          tag=$(gh api repos/openpgpjs/openpgpjs/releases/latest --jq .tag_name)
          if [ -z "$tag" ] || [ "$tag" = "null" ]; then
            echo "Failed to resolve latest tag" >&2
            exit 1
          fi
          ver=${tag#v}
          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "version=$ver" >> "$GITHUB_OUTPUT"

      - name: Download source and build bundle
        run: |
          set -euo pipefail
          tag="${{ steps.release.outputs.tag }}"

          export GNUPGHOME="$RUNNER_TEMP/gnupg"
          mkdir -p "$GNUPGHOME"
          chmod 700 "$GNUPGHOME"

          while IFS= read -r entry; do
            [ -z "$entry" ] && continue
            username=${entry%%:*}
            fpr=${entry#*:}
            if [ -z "$username" ] || [ -z "$fpr" ]; then
              echo "Invalid OPENPGPJS_SIGNER_FPRS entry: $entry" >&2
              exit 1
            fi
            if ! printf '%s' "$fpr" | grep -Eq '^[0-9A-Fa-f]{40}$'; then
              echo "Invalid fingerprint format for $username: $fpr" >&2
              exit 1
            fi
            keyfile="$RUNNER_TEMP/${username}.gpg"
            curl -fsSL "https://github.com/${username}.gpg" \
              | sed 's/-----END PGP PUBLIC KEY BLOCK-----/-----END PGP PUBLIC KEY BLOCK-----\n/g' \
              > "$keyfile"
            gpg --batch --import "$keyfile"
            if ! gpg --batch --with-colons --fingerprint \
              | awk -F: '$1=="fpr"{print $10}' \
              | grep -Fx "$fpr" >/dev/null; then
              echo "Expected fingerprint not found for $username: $fpr" >&2
              exit 1
            fi
          done <<EOF_FPRS
          ${{ env.OPENPGPJS_SIGNER_FPRS }}
          EOF_FPRS

          git init openpgpjs-src
          cd openpgpjs-src
          git remote add origin https://github.com/openpgpjs/openpgpjs.git
          git fetch --depth=1 origin "refs/tags/${tag}:refs/tags/${tag}"
          git -c gpg.program=gpg verify-tag "${tag}"
          git checkout -q "${tag}"

          npm ci
          npm audit signatures
          npm test

          cd ..
          mkdir -p build_artifact
          if [ ! -f "openpgpjs-src/dist/openpgp.min.mjs" ]; then
            echo "dist/openpgp.min.mjs not found after build" >&2
            exit 1
          fi
          cp "openpgpjs-src/dist/openpgp.min.mjs" build_artifact/openpgp.min.mjs
          printf '%s\n' "${{ steps.release.outputs.version }}" > build_artifact/openpgp.version.txt

      - name: Update vendor bundle in site tree
        run: |
          set -euo pipefail
          mkdir -p site/vendor
          cp build_artifact/openpgp.min.mjs site/vendor/openpgp.min.mjs
          cp build_artifact/openpgp.version.txt site/vendor/openpgp.version.txt

      - name: Prepare deploy trees (plain + __br)
        run: |
          set -euo pipefail
          rm -rf build_site_plain build_site__br
          mkdir -p build_site_plain build_site__br
          rsync -a --delete site/ build_site_plain/

          # brotli 対象リスト
          find build_site_plain -type f -regextype posix-extended -iregex "${BROTLI_REGEX}" -printf '%P\n' \
            | LC_ALL=C sort > brotli_file_list.txt

          # __br に圧縮して同名で生成
          while IFS= read -r rel; do
            [ -z "$rel" ] && continue
            src="build_site_plain/$rel"
            dst="build_site__br/$rel"
            mkdir -p "$(dirname "$dst")"
            brotli -f -q 11 -o "$dst" "$src"
          done < brotli_file_list.txt

      - name: Upload artifacts (site trees + brotli list)
        uses: actions/upload-artifact@v6
        with:
          name: site-deploy
          path: |
            build_site_plain
            build_site__br
            brotli_file_list.txt
          if-no-files-found: error

  deploy:
    runs-on: ubuntu-latest
    needs: build
    permissions:
      contents: read
      actions: read
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v7
        with:
          name: site-deploy
          path: deploy_artifact

      - name: Sync uncompressed tree to Cloudflare R2 (baseline)
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: auto
          AWS_EC2_METADATA_DISABLED: "true"
          BUCKET_NAME: ${{ secrets.BUCKET_NAME }}
          ENDPOINT_URL: ${{ secrets.ENDPOINT_URL }}
        run: |
          set -euo pipefail
          aws s3 sync deploy_artifact/build_site_plain "s3://$BUCKET_NAME" \
            --endpoint-url "$ENDPOINT_URL" --delete

      - name: Sync brotli objects under __br/ with Content-Encoding br
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: auto
          AWS_EC2_METADATA_DISABLED: "true"
          BUCKET_NAME: ${{ secrets.BUCKET_NAME }}
          ENDPOINT_URL: ${{ secrets.ENDPOINT_URL }}
        run: |
          set -euo pipefail
          aws s3 sync deploy_artifact/build_site__br "s3://$BUCKET_NAME/__br" \
            --endpoint-url "$ENDPOINT_URL" \
            --content-encoding br \
            --delete
